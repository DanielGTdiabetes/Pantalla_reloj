#!/usr/bin/env python3
"""Synchronize pantalla-bg-generate timer interval with config.json."""
from __future__ import annotations

import json
import subprocess
from pathlib import Path

CONFIG_PATH = Path("/etc/pantalla-dash/config.json")
TIMER_OVERRIDE_DIR = Path("/etc/systemd/system/pantalla-bg-generate.timer.d")
TIMER_OVERRIDE_FILE = TIMER_OVERRIDE_DIR / "override.conf"
TIMER_UNIT = "pantalla-bg-generate.timer"
SERVICE_UNIT = "pantalla-bg-generate.service"
DEFAULT_INTERVAL_MIN = 60
MIN_INTERVAL_MIN = 1
MAX_INTERVAL_MIN = 1440


class SyncError(Exception):
    """Raised when synchronization fails."""


def _load_interval() -> int:
    """Return sanitized interval in minutes from config.json."""
    interval = DEFAULT_INTERVAL_MIN
    try:
        raw = json.loads(CONFIG_PATH.read_text(encoding="utf-8"))
        data = raw
        if isinstance(raw, dict) and "config" in raw and isinstance(raw["config"], dict):
            data = raw["config"]
        if isinstance(data, dict) and "background" in data and isinstance(data["background"], dict):
            candidate = data["background"].get("intervalMinutes")
        else:
            candidate = None
        if candidate is not None:
            if isinstance(candidate, (int, float)):
                interval = int(candidate)
            elif isinstance(candidate, str) and candidate.strip():
                interval = int(float(candidate.strip()))
    except FileNotFoundError:
        pass
    except (json.JSONDecodeError, ValueError, TypeError) as exc:
        raise SyncError(f"Config inválido: {exc}") from exc

    interval = max(MIN_INTERVAL_MIN, min(MAX_INTERVAL_MIN, interval))
    if interval <= 0:
        interval = DEFAULT_INTERVAL_MIN
    return interval


def _write_override(interval: int) -> None:
    TIMER_OVERRIDE_DIR.mkdir(parents=True, exist_ok=True)
    content = """[Unit]
Description=Timer fondos IA (override desde config.json)

[Timer]
OnBootSec=30s
OnUnitActiveSec={interval}min
AccuracySec=10s
RandomizedDelaySec=0
OnCalendar=
Unit={service}
""".format(interval=interval, service=SERVICE_UNIT)
    TIMER_OVERRIDE_FILE.write_text(content, encoding="utf-8")


def _run(cmd: list[str]) -> subprocess.CompletedProcess[str]:
    return subprocess.run(cmd, check=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)


def _run_no_check(cmd: list[str]) -> subprocess.CompletedProcess[str]:
    return subprocess.run(cmd, check=False, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)


def main() -> int:
    try:
        interval = _load_interval()
    except SyncError as exc:
        print(f"[pantalla-bg-sync] Aviso: {exc}. Usando {DEFAULT_INTERVAL_MIN} min.")
        interval = DEFAULT_INTERVAL_MIN

    _write_override(interval)

    for cmd in (
        ["systemctl", "daemon-reload"],
        ["systemctl", "enable", "--now", TIMER_UNIT],
        ["systemctl", "restart", TIMER_UNIT],
    ):
        try:
            result = _run(cmd)
            output = "\n".join(
                part.strip()
                for part in (result.stdout, result.stderr)
                if part and part.strip()
            )
            if output:
                print(output)
        except subprocess.CalledProcessError as exc:
            print(exc.stderr.strip())
            return exc.returncode

    print(f"Intervalo aplicado: {interval} minutos")

    timers = _run_no_check(["systemctl", "list-timers", "--no-legend", "--all"]).stdout.splitlines()
    match = next((line for line in timers if TIMER_UNIT in line), "")
    if match:
        print(match)
    else:
        print(f"No se encontró {TIMER_UNIT} en systemctl list-timers")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
